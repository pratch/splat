let cameras = [
    {
        id: 0,
        img_name: "00001",
        width: 1959,
        height: 1090,
        position: [
            -3.0089893469241797, -0.11086489695181866, -3.7527640949141428,
        ],
        rotation: [
            [0.876134201218856, 0.06925962026449776, 0.47706599800804744],
            [-0.04747421839895102, 0.9972110940209488, -0.057586739349882114],
            [-0.4797239414934443, 0.027805376500959853, 0.8769787916452908],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 1,
        img_name: "00009",
        width: 1959,
        height: 1090,
        position: [
            -2.5199776022057296, -0.09704735754873686, -3.6247725540304545,
        ],
        rotation: [
            [0.9982731285632193, -0.011928707708098955, -0.05751927260507243],
            [0.0065061360949636325, 0.9955928229282383, -0.09355533724430458],
            [0.058381769258182864, 0.09301955098900708, 0.9939511719154457],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 2,
        img_name: "00017",
        width: 1959,
        height: 1090,
        position: [
            -0.7737533667465242, -0.3364271945329695, -2.9358969417573753,
        ],
        rotation: [
            [0.9998813418672372, 0.013742375651625236, -0.0069605529394208224],
            [-0.014268370388586709, 0.996512943252834, -0.08220929105659476],
            [0.00580653013657589, 0.08229885200307129, 0.9965907801935302],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 3,
        img_name: "00025",
        width: 1959,
        height: 1090,
        position: [
            1.2198221749590001, -0.2196687861401182, -2.3183162007028453,
        ],
        rotation: [
            [0.9208648867765482, 0.0012010625395201253, 0.389880004297208],
            [-0.06298204172269357, 0.987319521752825, 0.14571693239364383],
            [-0.3847611242348369, -0.1587410451475895, 0.9092635249821667],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 4,
        img_name: "00033",
        width: 1959,
        height: 1090,
        position: [
            1.742387858893817, -0.13848225198886954, -2.0566370113193146,
        ],
        rotation: [
            [0.24669889292141334, -0.08370189346592856, -0.9654706879349405],
            [0.11343747891376445, 0.9919082664242816, -0.05700815184573074],
            [0.9624300466054861, -0.09545671285663988, 0.2541976029815521],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 5,
        img_name: "00041",
        width: 1959,
        height: 1090,
        position: [
            3.6567309419223935, -0.16470990600750707, -1.3458085590422042,
        ],
        rotation: [
            [0.2341293058324528, -0.02968330457755884, -0.9717522161434825],
            [0.10270823606832301, 0.99469554638321, -0.005638106875665722],
            [0.9667649592295676, -0.09848690996657204, 0.2359360976431732],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 6,
        img_name: "00049",
        width: 1959,
        height: 1090,
        position: [
            3.9013554243203497, -0.2597500978038105, -0.8106154188297828,
        ],
        rotation: [
            [0.6717235545638952, -0.015718162115524837, -0.7406351366386528],
            [0.055627354673906296, 0.9980224478387622, 0.029270992841185218],
            [0.7387104058127439, -0.060861588786650656, 0.6712695459756353],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 7,
        img_name: "00057",
        width: 1959,
        height: 1090,
        position: [4.742994605467533, -0.05591660945412069, 0.9500365976084458],
        rotation: [
            [-0.17042655709210375, 0.01207080756938, -0.9852964448542146],
            [0.1165090336695526, 0.9931575292530063, -0.00798543433078162],
            [0.9784581921120181, -0.1161568667478904, -0.1706667764862097],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 8,
        img_name: "00065",
        width: 1959,
        height: 1090,
        position: [4.34676307626522, 0.08168160516967145, 1.0876221470355405],
        rotation: [
            [-0.003575447631888379, -0.044792503246552894, -0.9989899137764799],
            [0.10770152645126597, 0.9931680875192705, -0.04491693593046672],
            [0.9941768441149182, -0.10775333677534978, 0.0012732004866391048],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
    {
        id: 9,
        img_name: "00073",
        width: 1959,
        height: 1090,
        position: [3.264984351114202, 0.078974937336732, 1.0117200284114904],
        rotation: [
            [-0.026919994628162257, -0.1565891128261527, -0.9872968974090509],
            [0.08444552208239385, 0.983768234577625, -0.1583319754069128],
            [0.9960643893290491, -0.0876350978794554, -0.013259786205163005],
        ],
        fy: 1164.6601287484507,
        fx: 1159.5880733038064,
    },
];

let camera = cameras[0];

function getProjectionMatrix(fx, fy, width, height) {
    const znear = 0.2;
    const zfar = 200;
    return [
        [(2 * fx) / width, 0, 0, 0],
        [0, -(2 * fy) / height, 0, 0],
        [0, 0, zfar / (zfar - znear), 1],
        [0, 0, -(zfar * znear) / (zfar - znear), 0],
    ].flat();
}

function getMeshProjectionMatrix(fx, fy, width, height) {
    const znear = 0.2;
    const zfar = 200;
    const aspect = width / height;
    const fov = 2 * Math.atan(height / (2 * fy));
    
    const f = 1 / Math.tan(fov / 2);
    return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (zfar + znear) / (znear - zfar), -1,
        0, 0, (2 * zfar * znear) / (znear - zfar), 0
    ];
}

function getViewMatrix(camera) {
    const R = camera.rotation.flat();
    const t = camera.position;
    const camToWorld = [
        [R[0], R[1], R[2], 0],
        [R[3], R[4], R[5], 0],
        [R[6], R[7], R[8], 0],
        [
            -t[0] * R[0] - t[1] * R[3] - t[2] * R[6],
            -t[0] * R[1] - t[1] * R[4] - t[2] * R[7],
            -t[0] * R[2] - t[1] * R[5] - t[2] * R[8],
            1,
        ],
    ].flat();
    return camToWorld;
}

function getMeshViewMatrix(camera) {
    // For mesh rendering, we need a proper world-to-camera view matrix
    const R = camera.rotation.flat();
    const t = camera.position;
    
    // Create world-to-camera view matrix
    return [
        R[0], R[3], R[6], 0,
        R[1], R[4], R[7], 0,
        R[2], R[5], R[8], 0,
        -(t[0] * R[0] + t[1] * R[1] + t[2] * R[2]),
        -(t[0] * R[3] + t[1] * R[4] + t[2] * R[5]),
        -(t[0] * R[6] + t[1] * R[7] + t[2] * R[8]),
        1
    ];
}
// function translate4(a, x, y, z) {
//     return [
//         ...a.slice(0, 12),
//         a[0] * x + a[4] * y + a[8] * z + a[12],
//         a[1] * x + a[5] * y + a[9] * z + a[13],
//         a[2] * x + a[6] * y + a[10] * z + a[14],
//         a[3] * x + a[7] * y + a[11] * z + a[15],
//     ];
// }

function multiply4(a, b) {
    return [
        b[0] * a[0] + b[1] * a[4] + b[2] * a[8] + b[3] * a[12],
        b[0] * a[1] + b[1] * a[5] + b[2] * a[9] + b[3] * a[13],
        b[0] * a[2] + b[1] * a[6] + b[2] * a[10] + b[3] * a[14],
        b[0] * a[3] + b[1] * a[7] + b[2] * a[11] + b[3] * a[15],
        b[4] * a[0] + b[5] * a[4] + b[6] * a[8] + b[7] * a[12],
        b[4] * a[1] + b[5] * a[5] + b[6] * a[9] + b[7] * a[13],
        b[4] * a[2] + b[5] * a[6] + b[6] * a[10] + b[7] * a[14],
        b[4] * a[3] + b[5] * a[7] + b[6] * a[11] + b[7] * a[15],
        b[8] * a[0] + b[9] * a[4] + b[10] * a[8] + b[11] * a[12],
        b[8] * a[1] + b[9] * a[5] + b[10] * a[9] + b[11] * a[13],
        b[8] * a[2] + b[9] * a[6] + b[10] * a[10] + b[11] * a[14],
        b[8] * a[3] + b[9] * a[7] + b[10] * a[11] + b[11] * a[15],
        b[12] * a[0] + b[13] * a[4] + b[14] * a[8] + b[15] * a[12],
        b[12] * a[1] + b[13] * a[5] + b[14] * a[9] + b[15] * a[13],
        b[12] * a[2] + b[13] * a[6] + b[14] * a[10] + b[15] * a[14],
        b[12] * a[3] + b[13] * a[7] + b[14] * a[11] + b[15] * a[15],
    ];
}

function invert4(a) {
    let b00 = a[0] * a[5] - a[1] * a[4];
    let b01 = a[0] * a[6] - a[2] * a[4];
    let b02 = a[0] * a[7] - a[3] * a[4];
    let b03 = a[1] * a[6] - a[2] * a[5];
    let b04 = a[1] * a[7] - a[3] * a[5];
    let b05 = a[2] * a[7] - a[3] * a[6];
    let b06 = a[8] * a[13] - a[9] * a[12];
    let b07 = a[8] * a[14] - a[10] * a[12];
    let b08 = a[8] * a[15] - a[11] * a[12];
    let b09 = a[9] * a[14] - a[10] * a[13];
    let b10 = a[9] * a[15] - a[11] * a[13];
    let b11 = a[10] * a[15] - a[11] * a[14];
    let det =
        b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) return null;
    return [
        (a[5] * b11 - a[6] * b10 + a[7] * b09) / det,
        (a[2] * b10 - a[1] * b11 - a[3] * b09) / det,
        (a[13] * b05 - a[14] * b04 + a[15] * b03) / det,
        (a[10] * b04 - a[9] * b05 - a[11] * b03) / det,
        (a[6] * b08 - a[4] * b11 - a[7] * b07) / det,
        (a[0] * b11 - a[2] * b08 + a[3] * b07) / det,
        (a[14] * b02 - a[12] * b05 - a[15] * b01) / det,
        (a[8] * b05 - a[10] * b02 + a[11] * b01) / det,
        (a[4] * b10 - a[5] * b08 + a[7] * b06) / det,
        (a[1] * b08 - a[0] * b10 - a[3] * b06) / det,
        (a[12] * b04 - a[13] * b02 + a[15] * b00) / det,
        (a[9] * b02 - a[8] * b04 - a[11] * b00) / det,
        (a[5] * b07 - a[4] * b09 - a[6] * b06) / det,
        (a[0] * b09 - a[1] * b07 + a[2] * b06) / det,
        (a[13] * b01 - a[12] * b03 - a[14] * b00) / det,
        (a[8] * b03 - a[9] * b01 + a[10] * b00) / det,
    ];
}

function rotate4(a, rad, x, y, z) {
    let len = Math.hypot(x, y, z);
    x /= len;
    y /= len;
    z /= len;
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let t = 1 - c;
    let b00 = x * x * t + c;
    let b01 = y * x * t + z * s;
    let b02 = z * x * t - y * s;
    let b10 = x * y * t - z * s;
    let b11 = y * y * t + c;
    let b12 = z * y * t + x * s;
    let b20 = x * z * t + y * s;
    let b21 = y * z * t - x * s;
    let b22 = z * z * t + c;
    return [
        a[0] * b00 + a[4] * b01 + a[8] * b02,
        a[1] * b00 + a[5] * b01 + a[9] * b02,
        a[2] * b00 + a[6] * b01 + a[10] * b02,
        a[3] * b00 + a[7] * b01 + a[11] * b02,
        a[0] * b10 + a[4] * b11 + a[8] * b12,
        a[1] * b10 + a[5] * b11 + a[9] * b12,
        a[2] * b10 + a[6] * b11 + a[10] * b12,
        a[3] * b10 + a[7] * b11 + a[11] * b12,
        a[0] * b20 + a[4] * b21 + a[8] * b22,
        a[1] * b20 + a[5] * b21 + a[9] * b22,
        a[2] * b20 + a[6] * b21 + a[10] * b22,
        a[3] * b20 + a[7] * b21 + a[11] * b22,
        ...a.slice(12, 16),
    ];
}

function translate4(a, x, y, z) {
    return [
        ...a.slice(0, 12),
        a[0] * x + a[4] * y + a[8] * z + a[12],
        a[1] * x + a[5] * y + a[9] * z + a[13],
        a[2] * x + a[6] * y + a[10] * z + a[14],
        a[3] * x + a[7] * y + a[11] * z + a[15],
    ];
}

function createWorker(self) {
    let buffer;
    let vertexCount = 0;
    let viewProj;
    // 6*4 + 4 + 4 = 8*4
    // XYZ - Position (Float32)
    // XYZ - Scale (Float32)
    // RGBA - colors (uint8)
    // IJKL - quaternion/rot (uint8)
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    let lastProj = [];
    let depthIndex = new Uint32Array();
    let lastVertexCount = 0;

    var _floatView = new Float32Array(1);
    var _int32View = new Int32Array(_floatView.buffer);

    function floatToHalf(float) {
        _floatView[0] = float;
        var f = _int32View[0];

        var sign = (f >> 31) & 0x0001;
        var exp = (f >> 23) & 0x00ff;
        var frac = f & 0x007fffff;

        var newExp;
        if (exp == 0) {
            newExp = 0;
        } else if (exp < 113) {
            newExp = 0;
            frac |= 0x00800000;
            frac = frac >> (113 - exp);
            if (frac & 0x01000000) {
                newExp = 1;
                frac = 0;
            }
        } else if (exp < 142) {
            newExp = exp - 112;
        } else {
            newExp = 31;
            frac = 0;
        }

        return (sign << 15) | (newExp << 10) | (frac >> 13);
    }

    function packHalf2x16(x, y) {
        return (floatToHalf(x) | (floatToHalf(y) << 16)) >>> 0;
    }

    function generateTexture() {
        if (!buffer) return;
        const f_buffer = new Float32Array(buffer);
        const u_buffer = new Uint8Array(buffer);

        var texwidth = 1024 * 2; // Set to your desired width
        var texheight = Math.ceil((2 * vertexCount) / texwidth); // Set to your desired height
        var texdata = new Uint32Array(texwidth * texheight * 4); // 4 components per pixel (RGBA)
        var texdata_c = new Uint8Array(texdata.buffer);
        var texdata_f = new Float32Array(texdata.buffer);

        // Here we convert from a .splat file buffer into a texture
        // With a little bit more foresight perhaps this texture file
        // should have been the native format as it'd be very easy to
        // load it into webgl.
        for (let i = 0; i < vertexCount; i++) {
            // x, y, z
            texdata_f[8 * i + 0] = f_buffer[8 * i + 0];
            texdata_f[8 * i + 1] = f_buffer[8 * i + 1];
            texdata_f[8 * i + 2] = f_buffer[8 * i + 2];

            // r, g, b, a
            texdata_c[4 * (8 * i + 7) + 0] = u_buffer[32 * i + 24 + 0];
            texdata_c[4 * (8 * i + 7) + 1] = u_buffer[32 * i + 24 + 1];
            texdata_c[4 * (8 * i + 7) + 2] = u_buffer[32 * i + 24 + 2];
            texdata_c[4 * (8 * i + 7) + 3] = u_buffer[32 * i + 24 + 3];

            // quaternions
            let scale = [
                f_buffer[8 * i + 3 + 0],
                f_buffer[8 * i + 3 + 1],
                f_buffer[8 * i + 3 + 2],
            ];
            let rot = [
                (u_buffer[32 * i + 28 + 0] - 128) / 128,
                (u_buffer[32 * i + 28 + 1] - 128) / 128,
                (u_buffer[32 * i + 28 + 2] - 128) / 128,
                (u_buffer[32 * i + 28 + 3] - 128) / 128,
            ];

            // Compute the matrix product of S and R (M = S * R)
            const M = [
                1.0 - 2.0 * (rot[2] * rot[2] + rot[3] * rot[3]),
                2.0 * (rot[1] * rot[2] + rot[0] * rot[3]),
                2.0 * (rot[1] * rot[3] - rot[0] * rot[2]),

                2.0 * (rot[1] * rot[2] - rot[0] * rot[3]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[3] * rot[3]),
                2.0 * (rot[2] * rot[3] + rot[0] * rot[1]),

                2.0 * (rot[1] * rot[3] + rot[0] * rot[2]),
                2.0 * (rot[2] * rot[3] - rot[0] * rot[1]),
                1.0 - 2.0 * (rot[1] * rot[1] + rot[2] * rot[2]),
            ].map((k, i) => k * scale[Math.floor(i / 3)]);

            const sigma = [
                M[0] * M[0] + M[3] * M[3] + M[6] * M[6],
                M[0] * M[1] + M[3] * M[4] + M[6] * M[7],
                M[0] * M[2] + M[3] * M[5] + M[6] * M[8],
                M[1] * M[1] + M[4] * M[4] + M[7] * M[7],
                M[1] * M[2] + M[4] * M[5] + M[7] * M[8],
                M[2] * M[2] + M[5] * M[5] + M[8] * M[8],
            ];

            texdata[8 * i + 4] = packHalf2x16(4 * sigma[0], 4 * sigma[1]);
            texdata[8 * i + 5] = packHalf2x16(4 * sigma[2], 4 * sigma[3]);
            texdata[8 * i + 6] = packHalf2x16(4 * sigma[4], 4 * sigma[5]);
        }

        self.postMessage({ texdata, texwidth, texheight }, [texdata.buffer]);
    }

    function runSort(viewProj) {
        if (!buffer) return;
        const f_buffer = new Float32Array(buffer);
        if (lastVertexCount == vertexCount) {
            let dot =
                lastProj[2] * viewProj[2] +
                lastProj[6] * viewProj[6] +
                lastProj[10] * viewProj[10];
            if (Math.abs(dot - 1) < 0.01) {
                return;
            }
        } else {
            generateTexture();
            lastVertexCount = vertexCount;
        }

        console.time("sort");
        let maxDepth = -Infinity;
        let minDepth = Infinity;
        let sizeList = new Int32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++) {
            let depth =
                ((viewProj[2] * f_buffer[8 * i + 0] +
                    viewProj[6] * f_buffer[8 * i + 1] +
                    viewProj[10] * f_buffer[8 * i + 2]) *
                    4096) |
                0;
            sizeList[i] = depth;
            if (depth > maxDepth) maxDepth = depth;
            if (depth < minDepth) minDepth = depth;
        }

        // This is a 16 bit single-pass counting sort
        let depthInv = (256 * 256 - 1) / (maxDepth - minDepth);
        let counts0 = new Uint32Array(256 * 256);
        for (let i = 0; i < vertexCount; i++) {
            sizeList[i] = ((sizeList[i] - minDepth) * depthInv) | 0;
            counts0[sizeList[i]]++;
        }
        let starts0 = new Uint32Array(256 * 256);
        for (let i = 1; i < 256 * 256; i++)
            starts0[i] = starts0[i - 1] + counts0[i - 1];
        depthIndex = new Uint32Array(vertexCount);
        for (let i = 0; i < vertexCount; i++)
            depthIndex[starts0[sizeList[i]]++] = i;

        depthIndex = depthIndex.reverse();


        
        // change to back-to-front
        // for (let i = 0; i < vertexCount; i++)
        //         depthIndex[--counts0[sizeList[i]] + starts0[sizeList[i]]] = i;

        console.timeEnd("sort");

        lastProj = viewProj;
        self.postMessage({ depthIndex, viewProj, vertexCount }, [
            depthIndex.buffer,
        ]);
    }

    function processPlyBuffer(inputBuffer) {
        const ubuf = new Uint8Array(inputBuffer);
        // 10KB ought to be enough for a header...
        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
        const header_end = "end_header\n";
        const header_end_index = header.indexOf(header_end);
        if (header_end_index < 0)
            throw new Error("Unable to read .ply file header");
        const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
        console.log("Vertex Count", vertexCount);
        let row_offset = 0,
            offsets = {},
            types = {};
        const TYPE_MAP = {
            double: "getFloat64",
            int: "getInt32",
            uint: "getUint32",
            float: "getFloat32",
            short: "getInt16",
            ushort: "getUint16",
            uchar: "getUint8",
        };
        for (let prop of header
            .slice(0, header_end_index)
            .split("\n")
            .filter((k) => k.startsWith("property "))) {
            const [p, type, name] = prop.split(" ");
            const arrayType = TYPE_MAP[type] || "getInt8";
            types[name] = arrayType;
            offsets[name] = row_offset;
            row_offset += parseInt(arrayType.replace(/[^\d]/g, "")) / 8;
        }
        console.log("Bytes per row", row_offset, types, offsets);

        let dataView = new DataView(
            inputBuffer,
            header_end_index + header_end.length,
        );
        let row = 0;
        const attrs = new Proxy(
            {},
            {
                get(target, prop) {
                    if (!types[prop]) throw new Error(prop + " not found");
                    return dataView[types[prop]](
                        row * row_offset + offsets[prop],
                        true,
                    );
                },
            },
        );

        console.time("calculate importance");
        let sizeList = new Float32Array(vertexCount);
        let sizeIndex = new Uint32Array(vertexCount);
        for (row = 0; row < vertexCount; row++) {
            sizeIndex[row] = row;
            if (!types["scale_0"]) continue;
            const size =
                Math.exp(attrs.scale_0) *
                Math.exp(attrs.scale_1) *
                Math.exp(attrs.scale_2);
            const opacity = 1 / (1 + Math.exp(-attrs.opacity));
            sizeList[row] = size * opacity;
        }
        console.timeEnd("calculate importance");

        console.time("sort");
        sizeIndex.sort((b, a) => sizeList[a] - sizeList[b]);
        console.timeEnd("sort");

        // 6*4 + 4 + 4 = 8*4
        // XYZ - Position (Float32)
        // XYZ - Scale (Float32)
        // RGBA - colors (uint8)
        // IJKL - quaternion/rot (uint8)
        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
        const buffer = new ArrayBuffer(rowLength * vertexCount);

        console.time("build buffer");
        for (let j = 0; j < vertexCount; j++) {
            row = sizeIndex[j];

            const position = new Float32Array(buffer, j * rowLength, 3);
            const scales = new Float32Array(buffer, j * rowLength + 4 * 3, 3);
            const rgba = new Uint8ClampedArray(
                buffer,
                j * rowLength + 4 * 3 + 4 * 3,
                4,
            );
            const rot = new Uint8ClampedArray(
                buffer,
                j * rowLength + 4 * 3 + 4 * 3 + 4,
                4,
            );

            if (types["scale_0"]) {
                const qlen = Math.sqrt(
                    attrs.rot_0 ** 2 +
                        attrs.rot_1 ** 2 +
                        attrs.rot_2 ** 2 +
                        attrs.rot_3 ** 2,
                );

                rot[0] = (attrs.rot_0 / qlen) * 128 + 128;
                rot[1] = (attrs.rot_1 / qlen) * 128 + 128;
                rot[2] = (attrs.rot_2 / qlen) * 128 + 128;
                rot[3] = (attrs.rot_3 / qlen) * 128 + 128;

                scales[0] = Math.exp(attrs.scale_0);
                scales[1] = Math.exp(attrs.scale_1);
                scales[2] = Math.exp(attrs.scale_2);
            } else {
                scales[0] = 0.01;
                scales[1] = 0.01;
                scales[2] = 0.01;

                rot[0] = 255;
                rot[1] = 0;
                rot[2] = 0;
                rot[3] = 0;
            }

            position[0] = attrs.x;
            position[1] = attrs.y;
            position[2] = attrs.z;

            if (types["f_dc_0"]) {
                const SH_C0 = 0.28209479177387814;
                rgba[0] = (0.5 + SH_C0 * attrs.f_dc_0) * 255;
                rgba[1] = (0.5 + SH_C0 * attrs.f_dc_1) * 255;
                rgba[2] = (0.5 + SH_C0 * attrs.f_dc_2) * 255;
            } else {
                rgba[0] = attrs.red;
                rgba[1] = attrs.green;
                rgba[2] = attrs.blue;
            }
            if (types["opacity"]) {
                rgba[3] = (1 / (1 + Math.exp(-attrs.opacity))) * 255;
            } else {
                rgba[3] = 255;
            }
        }
        console.timeEnd("build buffer");
        return buffer;
    }

    const throttledSort = () => {
        if (!sortRunning) {
            sortRunning = true;
            let lastView = viewProj;
            runSort(lastView);
            setTimeout(() => {
                sortRunning = false;
                if (lastView !== viewProj) {
                    throttledSort();
                }
            }, 0);
        }
    };

    let sortRunning;
    self.onmessage = (e) => {
        if (e.data.ply) {
            vertexCount = 0;
            runSort(viewProj);
            buffer = processPlyBuffer(e.data.ply);
            vertexCount = Math.floor(buffer.byteLength / rowLength);
            postMessage({ buffer: buffer, save: !!e.data.save });
        } else if (e.data.buffer) {
            buffer = e.data.buffer;
            vertexCount = e.data.vertexCount;
        } else if (e.data.vertexCount) {
            vertexCount = e.data.vertexCount;
        } else if (e.data.view) {
            viewProj = e.data.view;
            throttledSort();
        }
    };
}

const vertexShaderSource = `
#version 300 es
precision highp float;
precision highp int;

uniform highp usampler2D u_texture;
uniform sampler2D u_edgeVisibilityTexture;  // Edge visibility texture for GS culling
uniform mat4 projection, view;
uniform vec2 focal;
uniform vec2 viewport;
uniform float u_edgeVisibilityInfluence;  // Control how much edge visibility affects alpha
uniform float u_edgeVisibilityThreshold; // Threshold for edge visibility

in vec2 position;
in int index;

out vec4 vColor;
out vec2 vPosition;

void main () {
    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);
    vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1);
    vec4 pos2d = projection * cam;

    float clip = 1.2 * pos2d.w;
    if (pos2d.z < -clip || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
        return;
    }

    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);
    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);
    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);

    mat3 J = mat3(
        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z),
        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z),
        0., 0., 0.
    );

    mat3 T = transpose(mat3(view)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if(lambda2 < 0.0) return;
    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    // Sample edge visibility from texture (high at edges, low on flat surfaces)
    vec2 screenPos = (vec2(pos2d) / pos2d.w) * 0.5 + 0.5;
    float edgeVisibility = texture(u_edgeVisibilityTexture, screenPos).r;

    // Hard cutoff for visibility below threshold (gradual fade in/out starting at 0.5 * threshold)
    // Discard splats below hard cutoff
    float hardCutoff = u_edgeVisibilityThreshold * 0.5; 
    if (edgeVisibility < hardCutoff) {
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0); // Move outside clip space
        return;
    }

    // Smooth transition zone between hardCutoff and threshold 
    float transitionFactor = smoothstep(hardCutoff, u_edgeVisibilityThreshold, edgeVisibility);

    // Apply both edge visibility and transition factor to alpha
    float alphaMultiplier = edgeVisibility * transitionFactor;

    // Clamp alphaMultiplier based on influence
    alphaMultiplier = mix(1.0, alphaMultiplier, u_edgeVisibilityInfluence);

    // Apply alpha multiplier to original alpha
    float originalAlpha = float((cov.w >> 24) & 0xffu) / 255.0;
    float modifiedAlpha = originalAlpha * alphaMultiplier;

    // vColor = clamp(pos2d.z/pos2d.w+1.0, 0.0, 1.0) * vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;
    vColor = clamp(pos2d.z/pos2d.w+1.0, 0.0, 1.0) * vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, modifiedAlpha * 255.0) / 255.0;
    vPosition = position;

    vec2 vCenter = vec2(pos2d) / pos2d.w;
    float depth = pos2d.z / pos2d.w;
    gl_Position = vec4(
        vCenter
        + position.x * majorAxis / viewport
        + position.y * minorAxis / viewport, depth, 1.0);

    // Add small depth bias to push Gaussians slightly back
    // gl_Position.z -= 0.01; // Adjust this value as needed

}
`.trim();

const fragmentShaderSource = `
#version 300 es
precision highp float;

in vec4 vColor;
in vec2 vPosition;

out vec4 fragColor;

void main () {
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    float B = exp(A) * (vColor.a);
    fragColor = vec4(B * vColor.rgb, B);
}

`.trim();

// mesh shader
const meshVertexShaderSource = `
#version 300 es
precision highp float;

in vec3 aPosition;
in vec3 aNormal;
in vec3 aColor;

uniform mat4 uProjectionMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uModelMatrix;

flat out vec3 vNormal;  // flat interpolation preserves triangle normal
out vec3 vColor;
out vec3 vWorldPos;

vec3 linear_to_srgb(vec3 c){
  bvec3 m = lessThanEqual(c, vec3(0.0031308));
  vec3 lo = c * 12.92;
  vec3 hi = 1.055 * pow(c, vec3(1.0/2.4)) - 0.055;
  return mix(hi, lo, vec3(m));
}


void main() {
    vNormal = mat3(uModelMatrix) * aNormal;
    // vColor = aColor;
    vColor = linear_to_srgb(aColor);
    // vColor = linear_to_srgb(aNormal); // visualize normals as vert color

    vec4 worldPos = uModelMatrix * vec4(aPosition, 1.0);
    vWorldPos = worldPos.xyz;

    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
}
`.trim();

const meshFragmentShaderSource = `
#version 300 es
precision mediump float;

flat in vec3 vNormal;
in vec3 vColor;
in vec3 vWorldPos;
uniform vec3 uCameraPos;  // camera world-space position
uniform int uVisualizationMode; // 0: vertex color, 1: normals, 2: visibility score

out vec4 fragColor;

void main() {
    // vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
    // float diff = max(dot(normalize(vNormal), lightDir), 0.0);
    
    // // Combine vertex color with lighting
    // // vec3 diffuseColor = vColor * diff;
    // // vec3 ambientColor = vColor * 0.3; // ambient lighting
    // // vec3 finalColor = diffuseColor + ambientColor;

    // // vec3 finalColor = vColor;
    // // vec3 finalColor = normalize(vNormal) * 0.5 + 0.5; // visualize normals as color
    // // vec3 finalColor = normalize(uCameraPos - vWorldPos) * 0.5 + 0.5; // visualize view direction as color

    // vec3 viewdir = normalize(uCameraPos - vWorldPos);
    // float norm_v_cross_n = length(cross(viewdir, normalize(vNormal)));
    // float visibility = exp(-100.0 * (norm_v_cross_n-1.0) * (norm_v_cross_n-1.0));
    // vec3 finalColor = vec3(visibility); 

    vec3 finalColor;

    if (uVisualizationMode == 0) {
        // Vertex colors
        finalColor = vColor;
    } else if (uVisualizationMode == 1) {
        // Normals as color
        finalColor = normalize(vNormal) * 0.5 + 0.5;
    } else if (uVisualizationMode == 2) {
        // Visibility score
        vec3 viewdir = normalize(uCameraPos - vWorldPos);
        float norm_v_cross_n = length(cross(viewdir, normalize(vNormal)));
        float visibility = exp(-100.0 * (norm_v_cross_n-1.0) * (norm_v_cross_n-1.0));
        finalColor = vec3(visibility);
    } else if (uVisualizationMode == 3) {
        // Normals as color
        finalColor = vec3(1.0, 0.0, 0.0); // Red
    } else {
        // Default fallback
        finalColor = vColor;
    }
    
    
    fragColor = vec4(finalColor, 1.0);
}

`.trim();

const meshVisibilityFragmentShaderSource = `
#version 300 es
precision mediump float;

flat in vec3 vNormal;
in vec3 vColor;
in vec3 vWorldPos;
uniform vec3 uCameraPos;

out vec4 fragColor;

void main() {
    // Calculate edge visibility score (high at edges/silhouettes, low on flat surfaces)
    vec3 viewdir = normalize(uCameraPos - vWorldPos);
    float norm_v_cross_n = length(cross(viewdir, normalize(vNormal)));
    float edgeVisibility = exp(-100.0 * (norm_v_cross_n-1.0) * (norm_v_cross_n-1.0));
    
    // Output edge visibility to red channel for GS culling
    fragColor = vec4(edgeVisibility, 0.0, 0.0, 1.0);
}
`.trim();

// Dilation shader for expanding visibility mask
const dilationVertexShaderSource = `
#version 300 es
precision highp float;

in vec2 aPosition;
out vec2 vTexCoord;

void main() {
    vTexCoord = aPosition * 0.5 + 0.5;
    gl_Position = vec4(aPosition, 0.0, 1.0);
}
`.trim();

const dilationFragmentShaderSource = `
#version 300 es
precision highp float;

in vec2 vTexCoord;
out vec4 fragColor;

uniform sampler2D uSourceTexture;
uniform vec2 uTexelSize;
uniform int uKernelSize;

void main() {
    float maxVisibility = 0.0;
    int halfKernel = uKernelSize / 2;
    
    // Sample in a square kernel around the current pixel
    for (int dy = -halfKernel; dy <= halfKernel; dy++) {
        for (int dx = -halfKernel; dx <= halfKernel; dx++) {
            vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;
            float sampleValue = texture(uSourceTexture, vTexCoord + offset).r;
            maxVisibility = max(maxVisibility, sampleValue);
        }
    }
    
    fragColor = vec4(maxVisibility, 0.0, 0.0, 1.0);
}
`.trim();

let defaultViewMatrix = [
    0.47, 0.04, 0.88, 0, -0.11, 0.99, 0.02, 0, -0.88, -0.11, 0.47, 0, 0.07,
    0.03, 6.55, 1,
];
let viewMatrix = defaultViewMatrix;

// helper: createProgram and Shader
function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed: ", gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Shader compile failed: ", gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

// helper: parsePLY (mesh)
import * as THREE from "three";
import { PLYLoader } from "three/examples/jsm/loaders/PLYLoader.js";

async function main() {
    // Load scenes manifest dynamically
    let scenesManifest = null;
    let scenes = {};
    
    try {
        const manifestResponse = await fetch('scenes_manifest.json');
        scenesManifest = await manifestResponse.json();
        
        // Convert manifest to scenes object - only include scenes with .splat files
        for (const [key, sceneData] of Object.entries(scenesManifest.scenes)) {
            // Only include scenes that have a .splat file (not just .ply)
            if (sceneData.splat) {
                scenes[key] = {
                    splat: `${scenesManifest.dataDir}/${sceneData.splat}`,
                    mesh: `${scenesManifest.dataDir}/${sceneData.mesh}`,
                    displayName: sceneData.displayName
                };
            }
        }
        
        console.log(`Loaded ${Object.keys(scenes).length} scenes from manifest`);
    } catch (error) {
        console.error('Failed to load scenes manifest, using fallback scenes:', error);
        // Fallback to hardcoded scenes if manifest fails
        scenes = {
            playroom: {
                splat: "hybrid_data/playroom.splat",
                mesh: "hybrid_data/playroommesh.ply",
                displayName: "Playroom"
            },
            dtu24: {
                splat: "hybrid_data/dtu24.splat", 
                mesh: "hybrid_data/dtu24mesh.ply",
                displayName: "DTU24"
            },
            fox: {
                splat: "hybrid_data/fox.splat", 
                mesh: "hybrid_data/fox.ply",
                displayName: "Fox"
            },
            lion1: {
                splat: "hybrid_data/lion1.splat", 
                mesh: "hybrid_data/lion1mesh.ply",
                displayName: "Lion 1"
            },
            lion2: {
                splat: "hybrid_data/lion2.splat", 
                mesh: "hybrid_data/lion2mesh.ply",
                displayName: "Lion 2"
            },
            lion3: {
                splat: "hybrid_data/lion3.splat", 
                mesh: "hybrid_data/lion3mesh.ply",
                displayName: "Lion 3"
            }
        };
    }
    
    let currentScene = scenes['dtu_dtu-scan24'] ? 'dtu_dtu-scan24' : Object.keys(scenes)[0] || 'dtu_dtu-scan24';
    
    let carousel = true;
    const params = new URLSearchParams(location.search);
    try {
        viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
        carousel = false;
    } catch (err) {}
    // const url = new URL(
    //     // "nike.splat",
    //     // location.href,
    //     params.get("url") || "train.splat",
    //     "https://huggingface.co/cakewalk/splat-data/resolve/main/",
    // );

    // Remove original splat loading - will be handled by loadScene()
    // const url = new URL(params.get("url") || scenes[currentScene].splat, location.href);
    // const req = await fetch(url, { mode: "cors", credentials: "omit" });
    
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    
    const downsample = 1 / devicePixelRatio; // Will be updated when scene loads
    console.log("Initial downsample:", downsample);

    const worker = new Worker(
        URL.createObjectURL(
            new Blob(["(", createWorker.toString(), ")(self)"], {
                type: "application/javascript",
            }),
        ),
    );

    // Mesh data storage
    let meshData = null;
    
    // Display control variables
    let showMesh = true;
    let showSplats = true;
    
    // Variables for file loading
    let stopLoading = false;
    let splatData = new Uint8Array(0); // Initialize to empty array to avoid null errors


    const canvas = document.getElementById("canvas");
    const fps = document.getElementById("fps");
    const camid = document.getElementById("camid");
    
    // Setup display control toggles
    const showMeshToggle = document.getElementById("showMesh");
    const showSplatsToggle = document.getElementById("showSplats");
    const sceneSelect = document.getElementById("sceneSelect");
    const meshVisualizationSelect = document.getElementById("meshVisualizationMode");

    // Add visualization mode variable
    let meshVisualizationMode = 0; // Default to color

    // Add event listener for the dropdown
    meshVisualizationSelect.addEventListener("change", (e) => {
        meshVisualizationMode = parseInt(e.target.value);
    });

    // Add edge visibility influence control
    const edgeVisibilityInfluenceSlider = document.getElementById("visibilityInfluence");
    const edgeVisibilityValueDisplay = document.getElementById("visibilityValue");

    edgeVisibilityInfluenceSlider.addEventListener("input", (e) => {
        edgeVisibilityInfluence = parseFloat(e.target.value);
        edgeVisibilityValueDisplay.textContent = edgeVisibilityInfluence.toFixed(1);
    });

    // Add edge visibility threshold control
    const edgeVisibilityThresholdSlider = document.getElementById("visibilityThreshold");
    const thresholdValueDisplay = document.getElementById("thresholdValue");

    edgeVisibilityThresholdSlider.addEventListener("input", (e) => {
        edgeVisibilityThreshold = parseFloat(e.target.value);
        thresholdValueDisplay.textContent = edgeVisibilityThreshold.toFixed(2);
    });

    // Add dilation control toggle
    const enableDilationToggle = document.getElementById("enableDilation");
    enableDilationToggle.addEventListener("change", (e) => {
        enableDilation = e.target.checked;
    });

    // Add dilation kernel size control
    const dilationKernelSizeSlider = document.getElementById("dilationKernelSize");
    const dilationValueDisplay = document.getElementById("dilationValue");

    dilationKernelSizeSlider.addEventListener("input", (e) => {
        dilationKernelSize = parseInt(e.target.value);
        dilationValueDisplay.textContent = dilationKernelSize;
    });

    showMeshToggle.addEventListener("change", (e) => {
        showMesh = e.target.checked;
    });
    
    showSplatsToggle.addEventListener("change", (e) => {
        showSplats = e.target.checked;
    });
    
    // Populate scene selector dropdown
    sceneSelect.innerHTML = ''; // Clear existing options
    for (const [key, sceneData] of Object.entries(scenes)) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = sceneData.displayName || key;
        sceneSelect.appendChild(option);
    }
    
    sceneSelect.addEventListener("change", (e) => {
        loadScene(e.target.value);
    });
    
    // Set initial dropdown value
    sceneSelect.value = currentScene;

    let projectionMatrix;

    const gl = canvas.getContext("webgl2", {
        antialias: false,
        depth: true,
    });

    // Create edge visibility texture and framebuffer for GS culling
    let edgeVisibilityTexture = gl.createTexture();
    let edgeVisibilityFramebuffer = gl.createFramebuffer();
    let edgeVisibilityDepthBuffer = gl.createRenderbuffer();
    let edgeVisibilityTextureFormat = null; // Track which format we're using
    
    // Create dilated visibility texture and framebuffer
    let dilatedVisibilityTexture = gl.createTexture();
    let dilatedVisibilityFramebuffer = gl.createFramebuffer();
    
    function setupEdgeVisibilityTexture() {
        const width = gl.canvas.width;
        const height = gl.canvas.height;
        
        // Setup edge visibility texture - use R16F instead of R32F for better compatibility
        gl.bindTexture(gl.TEXTURE_2D, edgeVisibilityTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.R16F, width, height, 0, gl.RED, gl.HALF_FLOAT, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        // Setup depth buffer
        gl.bindRenderbuffer(gl.RENDERBUFFER, edgeVisibilityDepthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT24, width, height);
        
        // Setup framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, edgeVisibilityFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, edgeVisibilityTexture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, edgeVisibilityDepthBuffer);
        
        // Check framebuffer status and provide detailed error info
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
            console.error("Edge visibility framebuffer not complete. Status:", status);
            
            // Try fallback format if R16F doesn't work
            console.log("Trying fallback RGBA format...");
            gl.bindTexture(gl.TEXTURE_2D, edgeVisibilityTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            edgeVisibilityTextureFormat = 'RGBA_UBYTE';
            
            // Check again
            const newStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (newStatus !== gl.FRAMEBUFFER_COMPLETE) {
                console.error("Fallback framebuffer also failed. Status:", newStatus);
            } else {
                console.log("Fallback RGBA format works");
            }
        } else {
            edgeVisibilityTextureFormat = 'R16F';
        }
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
        // Setup dilated visibility texture and framebuffer
        gl.bindTexture(gl.TEXTURE_2D, dilatedVisibilityTexture);
        const internalFormat = edgeVisibilityTextureFormat === 'RGBA_UBYTE' ? gl.RGBA : gl.R16F;
        const format = edgeVisibilityTextureFormat === 'RGBA_UBYTE' ? gl.RGBA : gl.RED;
        const type = edgeVisibilityTextureFormat === 'RGBA_UBYTE' ? gl.UNSIGNED_BYTE : gl.HALF_FLOAT;
        
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, dilatedVisibilityFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dilatedVisibilityTexture, 0);
        
        const dilationStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (dilationStatus !== gl.FRAMEBUFFER_COMPLETE) {
            console.error("Dilated visibility framebuffer not complete. Status:", dilationStatus);
        }
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(vertexShader));

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(fragmentShader));

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.useProgram(program);

    const meshProgram = createProgram(gl, meshVertexShaderSource, meshFragmentShaderSource);
    const meshVisibilityProgram = createProgram(gl, meshVertexShaderSource, meshVisibilityFragmentShaderSource);
    const dilationProgram = createProgram(gl, dilationVertexShaderSource, dilationFragmentShaderSource);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
        console.error(gl.getProgramInfoLog(program));
    
    // Setup dilation program uniforms and geometry
    const dilationPositionLocation = gl.getAttribLocation(dilationProgram, "aPosition");
    const dilationSourceTextureLocation = gl.getUniformLocation(dilationProgram, "uSourceTexture");
    const dilationTexelSizeLocation = gl.getUniformLocation(dilationProgram, "uTexelSize");
    const dilationKernelSizeLocation = gl.getUniformLocation(dilationProgram, "uKernelSize");
    
    // Create fullscreen quad for dilation
    const dilationQuadVertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const dilationQuadBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dilationQuadBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, dilationQuadVertices, gl.STATIC_DRAW);
    
    const dilationVAO = gl.createVertexArray();
    gl.bindVertexArray(dilationVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, dilationQuadBuffer);
    gl.enableVertexAttribArray(dilationPositionLocation);
    gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bindVertexArray(null);
    
    // Function to apply dilation to visibility texture
    function applyDilation() {
        if (!enableDilation) return;
        
        const width = gl.canvas.width;
        const height = gl.canvas.height;
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, dilatedVisibilityFramebuffer);
        gl.viewport(0, 0, width, height);
        
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.BLEND);
        
        gl.useProgram(dilationProgram);
        
        // Bind source texture (edge visibility)
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, edgeVisibilityTexture);
        gl.uniform1i(dilationSourceTextureLocation, 0);
        
        // Set uniforms
        gl.uniform2f(dilationTexelSizeLocation, 1.0 / width, 1.0 / height);
        gl.uniform1i(dilationKernelSizeLocation, dilationKernelSize);
        
        // Draw fullscreen quad
        gl.bindVertexArray(dilationVAO);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.bindVertexArray(null);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    gl.disable(gl.DEPTH_TEST); // Disable depth testing

    // Enable blending
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_DST_ALPHA,
        gl.ONE,
    );
    gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

    const u_projection = gl.getUniformLocation(program, "projection");
    const u_viewport = gl.getUniformLocation(program, "viewport");
    const u_focal = gl.getUniformLocation(program, "focal");
    const u_view = gl.getUniformLocation(program, "view");

    // positions
    const triangleVertices = new Float32Array([-2, -2, 2, -2, 2, 2, -2, 2]);
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, triangleVertices, gl.STATIC_DRAW);
    
    const indexBuffer = gl.createBuffer();

    // Create VAO for splat rendering
    const splatVAO = gl.createVertexArray();
    gl.bindVertexArray(splatVAO);
    
    const a_position = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(a_position);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

    const a_index = gl.getAttribLocation(program, "index");
    gl.enableVertexAttribArray(a_index);
    gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
    gl.vertexAttribIPointer(a_index, 1, gl.INT, false, 0, 0);
    gl.vertexAttribDivisor(a_index, 1);
    
    gl.bindVertexArray(null); // Unbind VAO

    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    var u_textureLocation = gl.getUniformLocation(program, "u_texture");
    gl.uniform1i(u_textureLocation, 0);

    // Function to load a new scene
    async function loadScene(sceneName) {
        if (!scenes[sceneName]) {
            console.error("Scene not found:", sceneName);
            return;
        }
        
        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
        const isPly = (splatData) =>
            splatData[0] == 112 &&
            splatData[1] == 108 &&
            splatData[2] == 121 &&
            splatData[3] == 10;
        
        currentScene = sceneName;
        console.log("Loading scene:", sceneName);
        
        // Show loading indicator
        document.getElementById("spinner").style.display = "";
        document.getElementById("message").innerText = `Loading ${sceneName}...`;
        
        // Reset mesh data
        meshData = null;
        
        try {
            // Load new splat file
            const splatUrl = new URL(scenes[sceneName].splat, location.href);
            const splatReq = await fetch(splatUrl, {
                mode: "cors",
                credentials: "omit",
            });
            
            if (splatReq.status !== 200) {
                throw new Error(`${splatReq.status} Unable to load ${splatReq.url}`);
            }
            
            const newSplatData = new Uint8Array(await splatReq.arrayBuffer());
            
            // Update global splatData for progress tracking
            splatData = newSplatData;
            
            if (isPly(newSplatData)) {
                worker.postMessage({ ply: newSplatData.buffer, save: false });
            } else {
                worker.postMessage({
                    buffer: newSplatData.buffer,
                    vertexCount: Math.floor(newSplatData.byteLength / rowLength),
                });
            }
            
            // Load new mesh
            const meshUrl = scenes[sceneName].mesh;
            console.log("Attempting to load mesh from:", meshUrl);
            console.log("Full resolved URL:", new URL(meshUrl, location.href).href);
            
            // Test if we can fetch the file directly and check size
            try {
                const testFetch = await fetch(meshUrl);
                console.log("Mesh fetch test - Status:", testFetch.status);
                const contentLength = testFetch.headers.get('content-length');
                console.log("Mesh fetch test - Content-Length:", contentLength, "bytes");
                console.log("Mesh fetch test - Content-Type:", testFetch.headers.get('content-type'));
                
                // Check if file is too large (Three.js might have limits)
                if (contentLength) {
                    const sizeMB = parseInt(contentLength) / (1024 * 1024);
                    console.log(`Mesh file size: ${sizeMB.toFixed(2)} MB`);
                    if (sizeMB > 100) {
                        console.warn("Warning: Large mesh file may cause issues with PLYLoader");
                    }
                }
                
                // Actually read some of the content to verify it's not empty
                const arrayBuffer = await testFetch.arrayBuffer();
                console.log("Mesh fetch - actual bytes received:", arrayBuffer.byteLength);
            } catch (err) {
                console.error("Mesh fetch test failed:", err);
            }
            
            loader.load(
                meshUrl,
                (geometry) => {
                    console.log("Mesh loaded successfully for", sceneName);
                    console.log("Geometry:", geometry);
                    console.log("Attributes:", geometry.attributes);
                    if (geometry.attributes.position) {
                        console.log("Position count:", geometry.attributes.position.count);
                    }
                    if (geometry.index) {
                        console.log("Index count:", geometry.index.count);
                    }
                    setupMesh(geometry);
                },
                (progress) => {
                    console.log("Mesh loading progress:", progress);
                },
                (error) => {
                    console.error("Error loading mesh for", sceneName, ":", error);
                }
            );
            
            // Clear loading message
            document.getElementById("message").innerText = "";
            
        } catch (error) {
            console.error("Error loading scene:", error);
            document.getElementById("message").innerText = `Error loading ${sceneName}: ${error.message}`;
        }
    }
    
    // Function to setup mesh (extracted from the original mesh loading code)
    function setupMesh(geometry) {
            console.log("setupMesh called");
            console.log("Geometry:", geometry);
            console.log("Available attributes:", geometry.attributes ? Object.keys(geometry.attributes) : "NO ATTRIBUTES");
            
            if (!geometry || !geometry.attributes) {
                console.error("Mesh geometry is null or has no attributes");
                return;
            }
            
            // Log all attributes in detail
            for (const [key, attr] of Object.entries(geometry.attributes)) {
                console.log(`Attribute '${key}':`, {
                    count: attr.count,
                    itemSize: attr.itemSize,
                    arrayLength: attr.array ? attr.array.length : 0,
                    type: attr.array ? attr.array.constructor.name : 'no array'
                });
            }
            
            if (!geometry.attributes.position) {
                console.error("Mesh geometry has no position attribute");
                return;
            }
            
            let positions = geometry.attributes.position.array;
            console.log("Positions length:", positions.length);
            
            let normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;
            console.log("Normals:", normals ? `${normals.length} values` : "none");
            
            let colors = null;
            
            // Check for vertex colors - PLY files might have 'color' or individual 'red', 'green', 'blue' attributes
            if (geometry.attributes.color) {
                colors = geometry.attributes.color.array;
                console.log("Found vertex colors (color attribute)");
            } else if (geometry.attributes.red && geometry.attributes.green && geometry.attributes.blue) {
                // Combine RGB attributes into a single color array
                const red = geometry.attributes.red.array;
                const green = geometry.attributes.green.array;
                const blue = geometry.attributes.blue.array;
                colors = new Float32Array(positions.length); // RGB, same length as positions
                
                for (let i = 0; i < red.length; i++) {
                    colors[i * 3] = red[i] / 255.0;     // R
                    colors[i * 3 + 1] = green[i] / 255.0; // G  
                    colors[i * 3 + 2] = blue[i] / 255.0;   // B
                }
                console.log("Found vertex colors (separate R,G,B attributes)");
            } else {
                // Generate default colors (light gray)
                colors = new Float32Array(positions.length);
                for (let i = 0; i < colors.length; i += 3) {
                    colors[i] = 0.8;     // R
                    colors[i + 1] = 0.8; // G  
                    colors[i + 2] = 0.8; // B
                }
                console.log("Generated default vertex colors");
            }
            
            let indices = geometry.index ? geometry.index.array : null;
            
            // Generate normals if none exist
            if (!normals && indices) {
                const triangleCount = indices.length / 3;

                // Create expanded arrays for positions, colors, and normals
                const expandedPositions = new Float32Array(triangleCount * 9); // 3 vertices  3 coords
                const expandedColors = new Float32Array(triangleCount * 9);
                const expandedNormals = new Float32Array(triangleCount * 9);
                
                for (let i = 0; i < triangleCount; i++) { // for each triangle
                    const i0 = indices[i * 3];
                    const i1 = indices[i * 3 + 1];
                    const i2 = indices[i * 3 + 2];
                    
                    // Get triangle vertices
                    const v0 = [positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2]];
                    const v1 = [positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]];
                    const v2 = [positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]];
                    
                    // Compute triangle normal
                    const edge1 = [v1[0] - v0[0], v1[1] - v0[1], v1[2] - v0[2]];
                    const edge2 = [v2[0] - v0[0], v2[1] - v0[1], v2[2] - v0[2]];
                    const normal = [
                        edge1[1] * edge2[2] - edge1[2] * edge2[1],
                        edge1[2] * edge2[0] - edge1[0] * edge2[2],
                        edge1[0] * edge2[1] - edge1[1] * edge2[0]
                    ];
                    
                    // Normalize
                    const length = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
                    if (length > 0) {
                        normal[0] /= length;
                        normal[1] /= length;
                        normal[2] /= length;
                    }
                    
                    // Store expanded data for all 3 vertices of this triangle
                    for (let j = 0; j < 3; j++) {
                        const vertexIndex = j === 0 ? i0 : j === 1 ? i1 : i2;
                        const outputIndex = i * 9 + j * 3;
                        
                        // Copy position
                        expandedPositions[outputIndex] = positions[vertexIndex * 3];
                        expandedPositions[outputIndex + 1] = positions[vertexIndex * 3 + 1];
                        expandedPositions[outputIndex + 2] = positions[vertexIndex * 3 + 2];
                        
                        // Copy color
                        expandedColors[outputIndex] = colors[vertexIndex * 3];
                        expandedColors[outputIndex + 1] = colors[vertexIndex * 3 + 1];
                        expandedColors[outputIndex + 2] = colors[vertexIndex * 3 + 2];
                        
                        // Same triangle normal for all 3 vertices
                        expandedNormals[outputIndex] = normal[0];
                        expandedNormals[outputIndex + 1] = normal[1];
                        expandedNormals[outputIndex + 2] = normal[2];
                    }
                }
                
                // Replace original arrays with expanded ones
                positions = expandedPositions;
                colors = expandedColors;
                normals = expandedNormals;
                indices = null; // No longer use indices - we'll render directly
                
                console.log("Generated triangle normals for mesh, num triangles:", triangleCount);
            }
            
            console.log("Mesh - Vertices:", positions.length / 3, "Indices:", indices ? indices.length : 0);
            console.log("Has normals:", !!normals, "Has colors:", !!colors);
            
            // Create buffers
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            
            let normalBuffer = null;
            if (normals) {
                normalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            }
            
            let colorBuffer = null;
            if (colors) {
                colorBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            }
            
            let meshIndexBuffer = null;
            if (indices) {
                meshIndexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
            }
            
            // Get uniform locations for mesh program
            const u_meshProjection = gl.getUniformLocation(meshProgram, "uProjectionMatrix");
            const u_meshView = gl.getUniformLocation(meshProgram, "uViewMatrix");
            const u_meshModel = gl.getUniformLocation(meshProgram, "uModelMatrix");
            const u_meshCameraPos = gl.getUniformLocation(meshProgram, "uCameraPos");
            const u_meshVisualizationMode = gl.getUniformLocation(meshProgram, "uVisualizationMode"); 

            // Get uniform locations for visibility program
            const u_meshVisibilityProjection = gl.getUniformLocation(meshVisibilityProgram, "uProjectionMatrix");
            const u_meshVisibilityView = gl.getUniformLocation(meshVisibilityProgram, "uViewMatrix");
            const u_meshVisibilityModel = gl.getUniformLocation(meshVisibilityProgram, "uModelMatrix");
            const u_meshVisibilityCameraPos = gl.getUniformLocation(meshVisibilityProgram, "uCameraPos");
            
            // Create VAO for mesh rendering (regular program)
            const meshVAO = gl.createVertexArray();
            gl.bindVertexArray(meshVAO);
            
            // Set up position attribute
            const positionLocation = gl.getAttribLocation(meshProgram, "aPosition");
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            
            // Set up normal attribute if available
            const normalLocation = gl.getAttribLocation(meshProgram, "aNormal");
            if (normalBuffer && normalLocation >= 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.enableVertexAttribArray(normalLocation);
                gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
            }
            
            // Set up color attribute if available
            const colorLocation = gl.getAttribLocation(meshProgram, "aColor");
            if (colorBuffer && colorLocation >= 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.enableVertexAttribArray(colorLocation);
                gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
            }
            
            // Bind index buffer
            if (meshIndexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshIndexBuffer);
            }
            
            gl.bindVertexArray(null); // Unbind VAO
            
            // Create separate VAO for visibility rendering
            const meshVisibilityVAO = gl.createVertexArray();
            gl.bindVertexArray(meshVisibilityVAO);
            
            // Set up position attribute for visibility shader
            const visPositionLocation = gl.getAttribLocation(meshVisibilityProgram, "aPosition");
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(visPositionLocation);
            gl.vertexAttribPointer(visPositionLocation, 3, gl.FLOAT, false, 0, 0);
            
            // Set up normal attribute for visibility shader
            const visNormalLocation = gl.getAttribLocation(meshVisibilityProgram, "aNormal");
            if (normalBuffer && visNormalLocation >= 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.enableVertexAttribArray(visNormalLocation);
                gl.vertexAttribPointer(visNormalLocation, 3, gl.FLOAT, false, 0, 0);
            }
            
            // Set up color attribute for visibility shader (needed for vertex shader)
            const visColorLocation = gl.getAttribLocation(meshVisibilityProgram, "aColor");
            if (colorBuffer && visColorLocation >= 0) {
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.enableVertexAttribArray(visColorLocation);
                gl.vertexAttribPointer(visColorLocation, 3, gl.FLOAT, false, 0, 0);
            }
            
            // Bind index buffer
            if (meshIndexBuffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshIndexBuffer);
            }
            
            gl.bindVertexArray(null); // Unbind VAO
            
            // Store mesh data for rendering
            meshData = {
                program: meshProgram,
                visibilityProgram: meshVisibilityProgram,
                vao: meshVAO,
                visibilityVAO: meshVisibilityVAO,
                positionBuffer,
                normalBuffer,
                colorBuffer,
                indexBuffer: meshIndexBuffer,
                vertexCount: positions.length / 3,
                indexCount: indices ? indices.length : 0,
                uniforms: {
                    projection: u_meshProjection,
                    view: u_meshView,
                    model: u_meshModel,
                    cameraPos: u_meshCameraPos,
                    visualizationMode: u_meshVisualizationMode
                },
                visibilityUniforms: {
                    projection: u_meshVisibilityProjection,
                    view: u_meshVisibilityView,
                    model: u_meshVisibilityModel,
                    cameraPos: u_meshVisibilityCameraPos
                }
            };
            
            console.log("Mesh loaded successfully");
    }
    
    // Initialize mesh loading after WebGL context is ready
    const loader = new PLYLoader();
    
    // Add logging to see what the loader is requesting
    loader.manager.onStart = (url, itemsLoaded, itemsTotal) => {
        console.log('Started loading:', url);
    };
    
    loader.manager.onLoad = () => {
        console.log('All loading complete');
    };
    
    loader.manager.onProgress = (url, itemsLoaded, itemsTotal) => {
        console.log('Loading progress:', url, itemsLoaded, '/', itemsTotal);
    };
    
    loader.manager.onError = (url) => {
        console.error('Error loading:', url);
    };
    
    // Load initial scene
    loadScene(currentScene);

    // Add uniform locations for GS program - edge visibility for culling at edges
    const u_edgeVisibilityTexture = gl.getUniformLocation(program, "u_edgeVisibilityTexture");
    const u_edgeVisibilityInfluence = gl.getUniformLocation(program, "u_edgeVisibilityInfluence");
    const u_edgeVisibilityThreshold = gl.getUniformLocation(program, "u_edgeVisibilityThreshold");

    // Add edge visibility influence control (for GS culling - keeps GS at edges, removes on flat surfaces)
    let edgeVisibilityInfluence = 1.0; // 0.0 = no influence, 1.0 = full influence
    let edgeVisibilityThreshold = 0.1;
    let enableDilation = true; // Enable dilation to expand visibility mask
    let dilationKernelSize = 5; // Kernel size for dilation (odd number)

    const resize = () => {
        gl.uniform2fv(u_focal, new Float32Array([camera.fx, camera.fy]));

        projectionMatrix = getProjectionMatrix(
            camera.fx,
            camera.fy,
            innerWidth,
            innerHeight,
        );

        gl.uniform2fv(u_viewport, new Float32Array([innerWidth, innerHeight]));

        gl.canvas.width = Math.round(innerWidth / downsample);
        gl.canvas.height = Math.round(innerHeight / downsample);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        gl.uniformMatrix4fv(u_projection, false, projectionMatrix);

        setupEdgeVisibilityTexture(); // Recreate edge visibility texture on resize
    };

    window.addEventListener("resize", resize);
    resize();

    worker.onmessage = (e) => {
        if (e.data.buffer) {
            splatData = new Uint8Array(e.data.buffer);
            if (e.data.save) {
                const blob = new Blob([splatData.buffer], {
                    type: "application/octet-stream",
                });
                const link = document.createElement("a");
                link.download = "model.splat";
                link.href = URL.createObjectURL(blob);
                document.body.appendChild(link);
                link.click();
            }
        } else if (e.data.texdata) {
            const { texdata, texwidth, texheight } = e.data;
            // console.log(texdata)
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_S,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(
                gl.TEXTURE_2D,
                gl.TEXTURE_WRAP_T,
                gl.CLAMP_TO_EDGE,
            );
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

            gl.texImage2D(
                gl.TEXTURE_2D,
                0,
                gl.RGBA32UI,
                texwidth,
                texheight,
                0,
                gl.RGBA_INTEGER,
                gl.UNSIGNED_INT,
                texdata,
            );
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
        } else if (e.data.depthIndex) {
            const { depthIndex, viewProj } = e.data;
            gl.bindBuffer(gl.ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, depthIndex, gl.DYNAMIC_DRAW);
            vertexCount = e.data.vertexCount;
        }
    };

    let activeKeys = [];
    let currentCameraIndex = 0;

    window.addEventListener("keydown", (e) => {
        // if (document.activeElement != document.body) return;
        carousel = false;
        if (!activeKeys.includes(e.code)) activeKeys.push(e.code);
        if (/\d/.test(e.key)) {
            currentCameraIndex = parseInt(e.key);
            camera = cameras[currentCameraIndex];
            viewMatrix = getViewMatrix(camera);
        }
        if (["-", "_"].includes(e.key)) {
            currentCameraIndex =
                (currentCameraIndex + cameras.length - 1) % cameras.length;
            viewMatrix = getViewMatrix(cameras[currentCameraIndex]);
        }
        if (["+", "="].includes(e.key)) {
            currentCameraIndex = (currentCameraIndex + 1) % cameras.length;
            viewMatrix = getViewMatrix(cameras[currentCameraIndex]);
        }
        camid.innerText = "cam  " + currentCameraIndex;
        if (e.code == "KeyV") {
            location.hash =
                "#" +
                JSON.stringify(
                    viewMatrix.map((k) => Math.round(k * 100) / 100),
                );
            camid.innerText = "";
        } else if (e.code === "KeyP") {
            carousel = true;
            camid.innerText = "";
        }
    });
    window.addEventListener("keyup", (e) => {
        activeKeys = activeKeys.filter((k) => k !== e.code);
    });
    window.addEventListener("blur", () => {
        activeKeys = [];
    });

    window.addEventListener(
        "wheel",
        (e) => {
            carousel = false;
            e.preventDefault();
            const lineHeight = 10;
            const scale =
                e.deltaMode == 1
                    ? lineHeight
                    : e.deltaMode == 2
                      ? innerHeight
                      : 1;
            let inv = invert4(viewMatrix);
            if (e.shiftKey) {
                inv = translate4(
                    inv,
                    (e.deltaX * scale) / innerWidth,
                    (e.deltaY * scale) / innerHeight,
                    0,
                );
            } else if (e.ctrlKey || e.metaKey) {
                // inv = rotate4(inv,  (e.deltaX * scale) / innerWidth,  0, 0, 1);
                // inv = translate4(inv,  0, (e.deltaY * scale) / innerHeight, 0);
                // let preY = inv[13];
                inv = translate4(
                    inv,
                    0,
                    0,
                    (-10 * (e.deltaY * scale)) / innerHeight,
                );
                // inv[13] = preY;
            } else {
                let d = 4;
                inv = translate4(inv, 0, 0, d);
                inv = rotate4(inv, -(e.deltaX * scale) / innerWidth, 0, 1, 0);
                inv = rotate4(inv, (e.deltaY * scale) / innerHeight, 1, 0, 0);
                inv = translate4(inv, 0, 0, -d);
            }

            viewMatrix = invert4(inv);
        },
        { passive: false },
    );

    let startX, startY, down;
    canvas.addEventListener("mousedown", (e) => {
        carousel = false;
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        down = e.ctrlKey || e.metaKey ? 2 : 1;
    });
    canvas.addEventListener("contextmenu", (e) => {
        carousel = false;
        e.preventDefault();
        startX = e.clientX;
        startY = e.clientY;
        down = 2;
    });

    canvas.addEventListener("mousemove", (e) => {
        e.preventDefault();
        if (down == 1) {
            let inv = invert4(viewMatrix);
            let dx = (5 * (e.clientX - startX)) / innerWidth;
            let dy = (5 * (e.clientY - startY)) / innerHeight;
            let d = 4;

            inv = translate4(inv, 0, 0, d);
            inv = rotate4(inv, dx, 0, 1, 0);
            inv = rotate4(inv, -dy, 1, 0, 0);
            inv = translate4(inv, 0, 0, -d);
            // let postAngle = Math.atan2(inv[0], inv[10])
            // inv = rotate4(inv, postAngle - preAngle, 0, 0, 1)
            // console.log(postAngle)
            viewMatrix = invert4(inv);

            startX = e.clientX;
            startY = e.clientY;
        } else if (down == 2) {
            let inv = invert4(viewMatrix);
            // inv = rotateY(inv, );
            // let preY = inv[13];
            inv = translate4(
                inv,
                (-10 * (e.clientX - startX)) / innerWidth,
                0,
                (10 * (e.clientY - startY)) / innerHeight,
            );
            // inv[13] = preY;
            viewMatrix = invert4(inv);

            startX = e.clientX;
            startY = e.clientY;
        }
    });
    canvas.addEventListener("mouseup", (e) => {
        e.preventDefault();
        down = false;
        startX = 0;
        startY = 0;
    });

    let altX = 0,
        altY = 0;
    canvas.addEventListener(
        "touchstart",
        (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                carousel = false;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                down = 1;
            } else if (e.touches.length === 2) {
                // console.log('beep')
                carousel = false;
                startX = e.touches[0].clientX;
                altX = e.touches[1].clientX;
                startY = e.touches[0].clientY;
                altY = e.touches[1].clientY;
                down = 1;
            }
        },
        { passive: false },
    );
    canvas.addEventListener(
        "touchmove",
        (e) => {
            e.preventDefault();
            if (e.touches.length === 1 && down) {
                let inv = invert4(viewMatrix);
                let dx = (4 * (e.touches[0].clientX - startX)) / innerWidth;
                let dy = (4 * (e.touches[0].clientY - startY)) / innerHeight;

                let d = 4;
                inv = translate4(inv, 0, 0, d);
                // inv = translate4(inv,  -x, -y, -z);
                // inv = translate4(inv,  x, y, z);
                inv = rotate4(inv, dx, 0, 1, 0);
                inv = rotate4(inv, -dy, 1, 0, 0);
                inv = translate4(inv, 0, 0, -d);

                viewMatrix = invert4(inv);

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // alert('beep')
                const dtheta =
                    Math.atan2(startY - altY, startX - altX) -
                    Math.atan2(
                        e.touches[0].clientY - e.touches[1].clientY,
                        e.touches[0].clientX - e.touches[1].clientX,
                    );
                const dscale =
                    Math.hypot(startX - altX, startY - altY) /
                    Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY,
                    );
                const dx =
                    (e.touches[0].clientX +
                        e.touches[1].clientX -
                        (startX + altX)) /
                    2;
                const dy =
                    (e.touches[0].clientY +
                        e.touches[1].clientY -
                        (startY + altY)) /
                    2;
                let inv = invert4(viewMatrix);
                // inv = translate4(inv,  0, 0, d);
                inv = rotate4(inv, dtheta, 0, 0, 1);

                inv = translate4(inv, -dx / innerWidth, -dy / innerHeight, 0);

                // let preY = inv[13];
                inv = translate4(inv, 0, 0, 3 * (1 - dscale));
                // inv[13] = preY;

                viewMatrix = invert4(inv);

                startX = e.touches[0].clientX;
                altX = e.touches[1].clientX;
                startY = e.touches[0].clientY;
                altY = e.touches[1].clientY;
            }
        },
        { passive: false },
    );
    canvas.addEventListener(
        "touchend",
        (e) => {
            e.preventDefault();
            down = false;
            startX = 0;
            startY = 0;
        },
        { passive: false },
    );

    let jumpDelta = 0;
    let vertexCount = 0;

    let lastFrame = 0;
    let avgFps = 0;
    let start = 0;
    let frameCount = 0;
    
    // Track visible gaussians
    let visibleGaussianCount = 0;
    let totalGaussianCount = 0;

    window.addEventListener("gamepadconnected", (e) => {
        const gp = navigator.getGamepads()[e.gamepad.index];
        console.log(
            `Gamepad connected at index ${gp.index}: ${gp.id}. It has ${gp.buttons.length} buttons and ${gp.axes.length} axes.`,
        );
    });
    window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected");
    });

    let leftGamepadTrigger, rightGamepadTrigger;


    // Function to extract camera world position from view matrix
    function getCameraWorldPosition(viewMatrix) {
        // The view matrix transforms from world space to camera space
        // Camera world position is the translation part of the inverse view matrix
        const invView = invert4(viewMatrix);
        return [invView[12], invView[13], invView[14]];
    }

    const frame = (now) => {
        let inv = invert4(viewMatrix);
        let shiftKey =
            activeKeys.includes("Shift") ||
            activeKeys.includes("ShiftLeft") ||
            activeKeys.includes("ShiftRight");

        if (activeKeys.includes("ArrowUp")) {
            if (shiftKey) {
                inv = translate4(inv, 0, -0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, 0.1);
            }
        }
        if (activeKeys.includes("ArrowDown")) {
            if (shiftKey) {
                inv = translate4(inv, 0, 0.03, 0);
            } else {
                inv = translate4(inv, 0, 0, -0.1);
            }
        }
        if (activeKeys.includes("ArrowLeft"))
            inv = translate4(inv, -0.03, 0, 0);
        //
        if (activeKeys.includes("ArrowRight"))
            inv = translate4(inv, 0.03, 0, 0);
        // inv = rotate4(inv, 0.01, 0, 1, 0);
        if (activeKeys.includes("KeyA")) inv = rotate4(inv, -0.01, 0, 1, 0);
        if (activeKeys.includes("KeyD")) inv = rotate4(inv, 0.01, 0, 1, 0);
        if (activeKeys.includes("KeyQ")) inv = rotate4(inv, 0.01, 0, 0, 1);
        if (activeKeys.includes("KeyE")) inv = rotate4(inv, -0.01, 0, 0, 1);
        if (activeKeys.includes("KeyW")) inv = rotate4(inv, 0.005, 1, 0, 0);
        if (activeKeys.includes("KeyS")) inv = rotate4(inv, -0.005, 1, 0, 0);

        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        let isJumping = activeKeys.includes("Space");
        for (let gamepad of gamepads) {
            if (!gamepad) continue;

            const axisThreshold = 0.1; // Threshold to detect when the axis is intentionally moved
            const moveSpeed = 0.06;
            const rotateSpeed = 0.02;

            // Assuming the left stick controls translation (axes 0 and 1)
            if (Math.abs(gamepad.axes[0]) > axisThreshold) {
                inv = translate4(inv, moveSpeed * gamepad.axes[0], 0, 0);
                carousel = false;
            }
            if (Math.abs(gamepad.axes[1]) > axisThreshold) {
                inv = translate4(inv, 0, 0, -moveSpeed * gamepad.axes[1]);
                carousel = false;
            }
            if (gamepad.buttons[12].pressed || gamepad.buttons[13].pressed) {
                inv = translate4(
                    inv,
                    0,
                    -moveSpeed *
                        (gamepad.buttons[12].pressed -
                            gamepad.buttons[13].pressed),
                    0,
                );
                carousel = false;
            }

            if (gamepad.buttons[14].pressed || gamepad.buttons[15].pressed) {
                inv = translate4(
                    inv,
                    -moveSpeed *
                        (gamepad.buttons[14].pressed -
                            gamepad.buttons[15].pressed),
                    0,
                    0,
                );
                carousel = false;
            }

            // Assuming the right stick controls rotation (axes 2 and 3)
            if (Math.abs(gamepad.axes[2]) > axisThreshold) {
                inv = rotate4(inv, rotateSpeed * gamepad.axes[2], 0, 1, 0);
                carousel = false;
            }
            if (Math.abs(gamepad.axes[3]) > axisThreshold) {
                inv = rotate4(inv, -rotateSpeed * gamepad.axes[3], 1, 0, 0);
                carousel = false;
            }

            let tiltAxis = gamepad.buttons[6].value - gamepad.buttons[7].value;
            if (Math.abs(tiltAxis) > axisThreshold) {
                inv = rotate4(inv, rotateSpeed * tiltAxis, 0, 0, 1);
                carousel = false;
            }
            if (gamepad.buttons[4].pressed && !leftGamepadTrigger) {
                camera =
                    cameras[(cameras.indexOf(camera) + 1) % cameras.length];
                inv = invert4(getViewMatrix(camera));
                carousel = false;
            }
            if (gamepad.buttons[5].pressed && !rightGamepadTrigger) {
                camera =
                    cameras[
                        (cameras.indexOf(camera) + cameras.length - 1) %
                            cameras.length
                    ];
                inv = invert4(getViewMatrix(camera));
                carousel = false;
            }
            leftGamepadTrigger = gamepad.buttons[4].pressed;
            rightGamepadTrigger = gamepad.buttons[5].pressed;
            if (gamepad.buttons[0].pressed) {
                isJumping = true;
                carousel = false;
            }
            if (gamepad.buttons[3].pressed) {
                carousel = true;
            }
        }

        if (
            ["KeyJ", "KeyK", "KeyL", "KeyI"].some((k) => activeKeys.includes(k))
        ) {
            let d = 4;
            inv = translate4(inv, 0, 0, d);
            inv = rotate4(
                inv,
                activeKeys.includes("KeyJ")
                    ? -0.05
                    : activeKeys.includes("KeyL")
                      ? 0.05
                      : 0,
                0,
                1,
                0,
            );
            inv = rotate4(
                inv,
                activeKeys.includes("KeyI")
                    ? 0.05
                    : activeKeys.includes("KeyK")
                      ? -0.05
                      : 0,
                1,
                0,
                0,
            );
            inv = translate4(inv, 0, 0, -d);
        }

        viewMatrix = invert4(inv);

        if (carousel) {
            let inv = invert4(defaultViewMatrix);

            const t = Math.sin((Date.now() - start) / 5000);
            inv = translate4(inv, 2.5 * t, 0, 6 * (1 - Math.cos(t)));
            inv = rotate4(inv, -0.6 * t, 0, 1, 0);

            viewMatrix = invert4(inv);
        }

        if (isJumping) {
            jumpDelta = Math.min(1, jumpDelta + 0.05);
        } else {
            jumpDelta = Math.max(0, jumpDelta - 0.05);
        }

        let inv2 = invert4(viewMatrix);
        inv2 = translate4(inv2, 0, -jumpDelta, 0);
        inv2 = rotate4(inv2, -0.1 * jumpDelta, 1, 0, 0);
        let actualViewMatrix = invert4(inv2);

        const viewProj = multiply4(projectionMatrix, actualViewMatrix);
        worker.postMessage({ view: viewProj });

        const currentFps = 1000 / (now - lastFrame) || 0;
        avgFps = avgFps * 0.9 + currentFps * 0.1;
        
        frameCount++;

        if (vertexCount > 0) {
            document.getElementById("spinner").style.display = "none";

            // Zeroth pass: Render mesh edge visibility to texture for GS culling
            if (meshData) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, edgeVisibilityFramebuffer);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);
                gl.depthMask(true);
                gl.disable(gl.BLEND);
                
                gl.useProgram(meshData.visibilityProgram);
                
                // Set uniforms for visibility pass
                gl.uniformMatrix4fv(meshData.visibilityUniforms.projection, false, projectionMatrix);
                gl.uniformMatrix4fv(meshData.visibilityUniforms.view, false, actualViewMatrix);
                
                const modelMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                gl.uniformMatrix4fv(meshData.visibilityUniforms.model, false, modelMatrix);
                
                const cameraWorldPos = getCameraWorldPosition(viewMatrix);
                gl.uniform3fv(meshData.visibilityUniforms.cameraPos, cameraWorldPos);
                
                // Use the visibility VAO (important!)
                gl.bindVertexArray(meshData.visibilityVAO);
                
                if (meshData.indexBuffer) {
                    gl.drawElements(gl.TRIANGLES, meshData.indexCount, gl.UNSIGNED_INT, 0);
                } else {
                    gl.drawArrays(gl.TRIANGLES, 0, meshData.vertexCount);
                }
                
                gl.bindVertexArray(null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                // Apply dilation to expand visibility mask
                applyDilation();
            }

            // First/Second pass: Render scene (mesh + splats)
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Enable depth testing for both mesh and splats
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LESS);
            gl.depthMask(true);
            
            // First pass: Render opaque mesh to establish depth buffer
            if (meshData && showMesh) {
                gl.disable(gl.BLEND);
                
                gl.useProgram(meshData.program);
                
                // Set uniforms - use the same projection matrix as splats for consistency
                gl.uniformMatrix4fv(meshData.uniforms.projection, false, projectionMatrix);
                gl.uniformMatrix4fv(meshData.uniforms.view, false, actualViewMatrix);
                
                // Identity model matrix for now
                const modelMatrix = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
                gl.uniformMatrix4fv(meshData.uniforms.model, false, modelMatrix);

                // Extract and pass camera world position
                const cameraWorldPos = getCameraWorldPosition(viewMatrix);
                gl.uniform3fv(meshData.uniforms.cameraPos, cameraWorldPos);

                // Pass visualization mode to shader
                gl.uniform1i(meshData.uniforms.visualizationMode, meshVisualizationMode);
                
                // Use mesh VAO
                gl.bindVertexArray(meshData.vao);
                
                // Render
                if (meshData.indexBuffer) {
                    gl.drawElements(gl.TRIANGLES, meshData.indexCount, gl.UNSIGNED_INT, 0);
                } else {
                    gl.drawArrays(gl.TRIANGLES, 0, meshData.vertexCount);
                }
                
                gl.bindVertexArray(null);
            }
            
            // Second pass: Render splats with proper depth testing
            if (showSplats) {
                // Count visible Gaussians based on edge visibility texture
                // (sample every 30 frames to avoid overhead)
                if (frameCount % 30 === 0 && meshData) {
                    totalGaussianCount = vertexCount;
                    
                    // Read edge visibility texture - use full resolution for accurate counting
                    const visWidth = gl.canvas.width;
                    const visHeight = gl.canvas.height;
                    
                    // Read based on the actual texture format
                    let visPixels;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, edgeVisibilityFramebuffer);
                    
                    if (edgeVisibilityTextureFormat === 'RGBA_UBYTE') {
                        // Read as UNSIGNED_BYTE and convert to float
                        const visPixelsBytes = new Uint8Array(visWidth * visHeight * 4);
                        gl.readPixels(0, 0, visWidth, visHeight, gl.RGBA, gl.UNSIGNED_BYTE, visPixelsBytes);
                        
                        // Convert to float
                        visPixels = new Float32Array(visPixelsBytes.length);
                        for (let i = 0; i < visPixelsBytes.length; i++) {
                            visPixels[i] = visPixelsBytes[i] / 255.0;
                        }
                    } else {
                        // Try reading as float (R16F format)
                        visPixels = new Float32Array(visWidth * visHeight * 4);
                        gl.readPixels(0, 0, visWidth, visHeight, gl.RGBA, gl.FLOAT, visPixels);
                    }
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    
                    // Count pixels above edge visibility threshold
                    let visiblePixels = 0;
                    let totalMeshPixels = 0;
                    
                    for (let i = 0; i < visPixels.length; i += 4) {
                        const edgeVis = visPixels[i];
                        if (edgeVis > 0.001) { // Mesh exists at this pixel
                            totalMeshPixels++;
                            if (edgeVis >= edgeVisibilityThreshold) {
                                visiblePixels++;
                            }
                        }
                    }
                    
                    // Estimate visible Gaussians based on pixel ratio
                    if (totalMeshPixels > 0) {
                        const visibleRatio = visiblePixels / totalMeshPixels;
                        visibleGaussianCount = Math.round(vertexCount * visibleRatio);
                    } else {
                        // No mesh visible - either all GS visible or use last known count
                        visibleGaussianCount = vertexCount;
                    }
                }
                
                gl.enable(gl.BLEND);
                gl.depthMask(false); // Don't write to depth buffer for splats (they're transparent)
                // gl.blendFuncSeparate(
                //     gl.ONE_MINUS_DST_ALPHA,
                //     gl.ONE,
                //     gl.ONE_MINUS_DST_ALPHA,
                //     gl.ONE,
                // );

                gl.blendFuncSeparate(
                    gl.ONE,           // src RGB factor
                    gl.ONE_MINUS_SRC_ALPHA, // dst RGB factor  
                    gl.ONE,                 // src alpha factor
                    gl.ONE_MINUS_SRC_ALPHA  // dst alpha factor
                );
                
                gl.useProgram(program);
                gl.uniformMatrix4fv(u_view, false, actualViewMatrix);

                // Bind edge visibility texture for GS culling (use dilated version if enabled)
                gl.activeTexture(gl.TEXTURE1);
                const visibilityTextureToUse = enableDilation ? dilatedVisibilityTexture : edgeVisibilityTexture;
                gl.bindTexture(gl.TEXTURE_2D, visibilityTextureToUse);
                gl.uniform1i(u_edgeVisibilityTexture, 1);
                
                // Set edge visibility influence
                gl.uniform1f(u_edgeVisibilityInfluence, edgeVisibilityInfluence);

                // Set edge visibility threshold
                gl.uniform1f(u_edgeVisibilityThreshold, edgeVisibilityThreshold);
                
                // Make sure splat texture is on texture unit 0
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);

                gl.bindVertexArray(splatVAO);
                gl.drawArraysInstanced(gl.TRIANGLE_FAN, 0, 4, vertexCount);
                gl.bindVertexArray(null);
            }
            
            // Restore state
            gl.depthMask(true);
        } else {
            gl.clear(gl.COLOR_BUFFER_BIT);
            document.getElementById("spinner").style.display = "";
            start = Date.now() + 2000;
        }
        if (splatData.length > 0) {
            const progress = (100 * vertexCount) / (splatData.length / rowLength);
            if (progress < 100) {
                document.getElementById("progress").style.width = progress + "%";
            } else {
                document.getElementById("progress").style.display = "none";
            }
        } else {
            document.getElementById("progress").style.display = "none";
        }
        
        // Display FPS and Gaussian counts
        const visiblePercent = totalGaussianCount > 0 ? ((visibleGaussianCount / totalGaussianCount) * 100).toFixed(1) : 0;
        fps.innerText = Math.round(avgFps) + " fps | " + 
                        visibleGaussianCount.toLocaleString() + " / " + 
                        totalGaussianCount.toLocaleString() + " GS (" + visiblePercent + "%)";
        
        if (isNaN(currentCameraIndex)) {
            camid.innerText = "";
        }
        lastFrame = now;
        requestAnimationFrame(frame);
    };

    frame();

    setupEdgeVisibilityTexture();

    const isPly = (splatData) =>
        splatData[0] == 112 &&
        splatData[1] == 108 &&
        splatData[2] == 121 &&
        splatData[3] == 10;

    const selectFile = (file) => {
        const fr = new FileReader();
        if (/\.json$/i.test(file.name)) {
            fr.onload = () => {
                cameras = JSON.parse(fr.result);
                viewMatrix = getViewMatrix(cameras[0]);
                projectionMatrix = getProjectionMatrix(
                    camera.fx / downsample,
                    camera.fy / downsample,
                    canvas.width,
                    canvas.height,
                );
                gl.uniformMatrix4fv(u_projection, false, projectionMatrix);

                console.log("Loaded Cameras");
            };
            fr.readAsText(file);
        } else {
            stopLoading = true;
            fr.onload = () => {
                splatData = new Uint8Array(fr.result);
                console.log("Loaded", Math.floor(splatData.length / rowLength));

                if (isPly(splatData)) {
                    // ply file magic header means it should be handled differently
                    worker.postMessage({ ply: splatData.buffer, save: true });
                } else {
                    worker.postMessage({
                        buffer: splatData.buffer,
                        vertexCount: Math.floor(splatData.length / rowLength),
                    });
                }
            };
            fr.readAsArrayBuffer(file);
        }
    };

    window.addEventListener("hashchange", (e) => {
        try {
            viewMatrix = JSON.parse(decodeURIComponent(location.hash.slice(1)));
            carousel = false;
        } catch (err) {}
    });

    const preventDefault = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    document.addEventListener("dragenter", preventDefault);
    document.addEventListener("dragover", preventDefault);
    document.addEventListener("dragleave", preventDefault);
    document.addEventListener("drop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        selectFile(e.dataTransfer.files[0]);
    });

    // Original splat loading code removed - now handled by loadScene()
    // The scene loading is initiated in loadScene(currentScene) call above
}

main().catch((err) => {
    console.error(err); // for debug
    document.getElementById("spinner").style.display = "none";
    document.getElementById("message").innerText = err.toString();
});
